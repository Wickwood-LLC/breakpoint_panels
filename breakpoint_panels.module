<?php
/**
 * @file
 * Breakpoint Panels for the Panels and Breakpoint modules.
 */

/**
 * Implements hook_menu().
 */
function breakpoint_panels_menu() {
  $items = array();
  $items['admin/config/user-interface/breakpoint_panels'] = array(
    'title' => 'Breakpoint Panels',
    'description' => 'Configure break point panels.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('breakpoint_panels_settings'),
    'access arguments' => array('administer breakpoints'),
    'type' => MENU_NORMAL_ITEM,
  );
  $items['breakpoint_panels/%ctools_js/settings/form/%/%'] = array(
    'title' => t('Breakpoints Pane'),
    'page callback' => 'breakpoint_panels_modal_popup',
    'page arguments' => array(1,4,5),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['breakpoint-panels/get-pane/%/%'] = array(
    'title' => 'Breakpoint Panels AJAX pane handler',
    'page callback' => 'breakpoint_panels_panels_pane_handler',
    'page arguments' => array(2, 3),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_libraries_info().
 */
function breakpoint_panels_libraries_info() {
  $libraries['enquire.js'] = array(
    'name' => 'enquire',
    'files' => array(
      'js' => array(
        'enquire.min.js',
      ),
    ),
  );
  $libraries['matchMedia.js'] = array(
    'name' => 'matchMedia.js',
    'files' => array(
      'js' => array(
        'matchMedia.addListener.js',
        'matchMedia.js',
      ),
    ),
  );

  return $libraries;
}

/**
 * Settings form callback.
 */
function breakpoint_panels_pane_settings_form($style_settings, $form_state) {
  $form = array();
  $bps = breakpoint_panels_get_breakpoints();
  $pid = $form_state['pane_id'];
  $did = $form_state['display_id'];
  $panel = panels_load_display($did);

  $pane = $panel->content[$pid];
  foreach ($bps as $name => $bp) {
    $form[$bp->breakpoint_panels_name] = array(
      '#type' => 'checkbox',
      '#title' => filter_xss(t('Display ' . $bp->name)),
      '#default_value' => !empty($pane->configuration['breakpoints']) ?  $pane->configuration['breakpoints'][$bp->breakpoint_panels_name] : TRUE
    );
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );
  $form['pane_id'] = array(
    '#type' => 'hidden',
    '#value' => $pid,
  );
  $form['display_id'] = array(
    '#type' => 'hidden',
    '#value' => $did,
  );

  return $form;
}

/**
 * Menu callback for settings form.
 */
function breakpoint_panels_settings($form, $form_state) {
  $form['breakpoint_panels_load_hidden_admins'] = array(
    '#title' => t('Load Hidden for Admins (recommended)'),
    '#type' => 'radios',
    '#options' => array(
      "no" => t("Don't Load"),
      "yes" => t('Load Hidden'),
    ),
    '#default_value' => variable_get('breakpoint_panels_load_hidden_admins', "yes"),
    '#description' => t('If selected, content will be loaded, but hidden via css for layout purposes.'),
  );
  $form['breakpoint_panels_load_hidden'] = array(
    '#title' => t('Load Hidden'),
    '#type' => 'radios',
    '#options' => array(
      "no" => t("Don't Load"),
      "yes" => t('Load Hidden'),
    ),
    '#default_value' => variable_get('breakpoint_panels_load_hidden', "no"),
    '#description' => t('If selected, content will be loaded, but hidden via css for development purposes.'),
  );
  $form['breakpoint_panels_breakpoint_reload'] = array(
    '#title' => t('Auto Reload'),
    '#type' => 'radios',
    '#options' => array(
      "no" => t("Don't Load"),
      "yes" => t('Auto Reload'),
    ),
    '#default_value' => variable_get('breakpoint_panels_breakpoint_reload', "no"),
    '#description' => t('If selected, content will be refreshed on resize if media queries change.  This will annoy users but may be handy for development.'),
  );
  return system_settings_form($form);
}

/**
 * Settings form submission.
 */
function breakpoint_panels_pane_settings_form_submit(&$form, &$form_state) {
  $display_id = $form['display_id']['#value'];
  $pane_id = $form['pane_id']['#value'];
  $display = panels_load_display($display_id);
  $pane = $display->content[$pane_id];
  $bps = breakpoint_panels_get_breakpoints();
  $pane->configuration['breakpoints'] = array();
  foreach ($bps as $bp) {
    if (!$bp) {
      continue;
    }
    $pane->configuration['breakpoints'][$bp->breakpoint_panels_name] = $form[$bp->breakpoint_panels_name]['#value'];
  }
  $display->content[$pane_id] = $pane;

  panels_save_display($display);

  ctools_include('object-cache');

  // If the cache is not updated the submitted settings in this form will be overwritten
  // when the page is saved.
  // todo: Pretty sure there should be a better way to do this. Had a hard time
  // trying to track down the exact ctools_object_cache to update so just looping
  // through all page manager caches for the current session. Suggestions welcome!
  $sid = session_id();
  $obj = 'page_manager_page';
  $session_caches = db_query('SELECT * FROM {ctools_object_cache} WHERE sid = :session_id AND obj = :object', array(':session_id' => $sid, ':object' => $obj));
  if (!empty($session_caches)) {
    foreach ($session_caches as $session_cache) {
      $cache = ctools_object_cache_get($obj, $session_cache->name, FALSE, $sid);

      if (!empty($cache->display_cache)) {
        foreach ($cache->display_cache as $dc => $display_cache) {
          if (!empty($display_cache->display->content)) {
            foreach ($display_cache->display->content as $dc_pid => $dc_pane) {
              if ($dc_pid == $pane_id && $dc_pane->did == $pane->did) {
                $cache->display_cache[$dc]->display->content[$dc_pid] = $pane;
              }
            }
          }
        }
      }
      ctools_object_cache_set($obj, $session_cache->name, $cache, $sid);
    }
  }
  $form_state['message'] = t('fixed');
}

/**
 * Implements hook_panels_ipe_pane_links_alter().
 */
function breakpoint_panels_panels_ipe_pane_links_alter(&$links, $pane, $display) {
  if (!empty($pane['pane']->did)) {
    $links['global'] = array(
      'title' => t('BP'),
      'href' => 'breakpoint_panels/nojs/settings/form/' . $pane['pane']->did . '/' . $pane['pane']->pid,
      'attributes' => array(
        'class' => 'ctools-use-modal ctools-modal-modal-popup-small',
      ),
    );
  }
}

/**
 * Creates a modal popup.
 */
function breakpoint_panels_modal_popup($js = NULL, $dis_id, $pane_id) {
  // degrade to no js
  $form_state = array(
    'title' => t('Breakpoints'),
    'ajax' => TRUE,
    'pane_id' => $pane_id,
    'display_id' => $dis_id,
  );
  if(!$js) {
    return drupal_get_form('breakpoint_panels_pane_settings_form', null, $pane_id);
  }
  ctools_include('modal');
  ctools_include('ajax');
  $output = ctools_modal_form_wrapper('breakpoint_panels_pane_settings_form', $form_state);
  if (!empty($form_state['executed'])) {
    // We'll just overwrite the form output if it was successful.
    $output = array();
    $output[] = ctools_modal_command_dismiss(t('Success!'));
  }
  print ajax_render($output);
  exit;
}

/**
 * Implements hook_panels_pre_render().
 */
function breakpoint_panels_panels_pre_render($display) {
  drupal_add_js(array(
    'breakpoint_panels_breakpoint' => breakpoint_panels_get_config(),
  ), 'setting');
}

/**
 * Returns the configuration for the breakpoint panels and a list of available breakpoints.
 */
function breakpoint_panels_get_config() {
  $conf = array();

  $valid = array(
    'width',
    'min-width',
    'max-width',
    'height',
    'min-height',
    'max-height',
    'aspect-ratio',
    'min-aspect-ratio',
    'max-aspect-ratio',
  );

  $bps = breakpoint_panels_get_breakpoints();
  foreach ($bps as $breakpoint) {
    if (!$breakpoint) continue;

    $conditions = breakpoint_panels_parse($breakpoint->breakpoint);

    $point = array();

    foreach ($conditions as $cmd => $value) {
      if (in_array($cmd, $valid)) {
        $point[$cmd] = $value;
      }
    }

    if (count($point)) {
      $conf[$breakpoint->machine_name] = $point;
      $conf[$breakpoint->machine_name]['bp'] = $breakpoint->breakpoint;
      $conf[$breakpoint->machine_name]['css'] = $breakpoint->breakpoint_panels_name;
    }
    $conf['autoload'] = (variable_get('breakpoint_panels_breakpoint_reload', "no")!="no") ? TRUE : FALSE;
    $conf['adminload'] = (variable_get('breakpoint_panels_load_hidden_admins', "yes")!="no") ? TRUE : FALSE;
    $conf['loadhidden'] = (variable_get('breakpoint_panels_load_hidden', "no")!="no") ? TRUE : FALSE;
    $conf['isloggedin'] = user_is_logged_in();
  }

  $conf['hasEnquire'] = libraries_get_path('enquire.js') ? TRUE : FALSE;
  $conf['hasMatchMedia'] = libraries_get_path('matchMedia.js') ? TRUE : FALSE;

  return $conf;
}

/**
 * Parse the min and max dimensions for a breakpoint.
 */
function breakpoint_panels_parse($query) {
  $query = str_replace(' ', '', $query);

  preg_match_all('/\(([a-z\-]+)\:(.+?)\)/', $query, $matches);

  $point = array();
  $count = count($matches[0]);
  for ($i = 0; $i < $count; $i++) {
    $cmd = $matches[1][$i];
    $value = $matches[2][$i];

    switch ($cmd) {
      case 'width':
      case 'min-width':
      case 'max-width':
      case 'height':
      case 'min-height':
      case 'max-height':
      case 'device-width':
      case 'min-device-width':
      case 'max-device-width':
      case 'device-height':
      case 'min-device-height':
      case 'max-device-height':
        // Only px values are supported.
        if (strpos($value, 'px') !== FALSE) {
          $point[$cmd] = (int) str_replace('px', '', $value);
        }
        break;

      case 'aspect-ratio':
      case 'min-aspect-ratio':
      case 'max-aspect-ratio':
      case 'device-aspect-ratio':
      case 'min-device-aspect-ratio':
      case 'max-device-aspect-ratio':
        $parts = explode('/', $value);

        if (count($parts) === 2 && is_numeric($parts[0]) && is_numeric($parts[1])) {
          $point[$cmd] = (float) $parts[0] / (float) $parts[1];
        }

        break;

      default:
        // Unsupported.
        break;
    }
  }

  return count($point) ? $point : FALSE;
}

/**
 * Menu handler to serve individual panel-panes via AJAX.
 *
 * If the pane uses context, the task_name, context_string and q variables will
 * be set.
 */
function breakpoint_panels_panels_pane_handler($display_id, $pane_id, $task_name = NULL, $context_string = NULL, $request_q = '') {

  ctools_include('plugins', 'panels');
  ctools_include('content');

  $context_args = array();
  if (!empty($request_q)) {
    $context_args = breakpoint_panels_decode_query($request_q);
  }

  $display = panels_load_display($display_id);

  if (!is_null($task_name)) {
    // Get the context for this pane.
    list($args, $contexts) = breakpoint_panels_panels_get_task_context($task_name);

    $display->context = $contexts;
    $display->args = $args;
  }

  $pane = $display->content[$pane_id];

  // Set flag so that we don't rewrite content.
  $pane->ajax_rendering = TRUE;
  $renderer = panels_get_renderer_handler($display->renderer, $display);

  $variables = array(
    'content' => $renderer->render_pane_content($pane),
    'pane' => $pane,
    'display' => $display,
  );

  echo theme('panels_pane', $variables);

  die();
}

/**
 * Decodes a serialized query string.
 *
 * Also sets $_GET and $_REQUEST variables.
 *
 * @param string $query
 *   A query string that is serialized encoded and base64 encoded.
 *
 * @return array
 *   The decoded query array.
 */
function breakpoint_panels_decode_query($query) {
  $query = unserialize(base64_decode($query));
  if ($query) {
    foreach ($query as $name => $value) {
      $_GET[$name] = $value;
      $_REQUEST[$name] = $value;
    }
  }
  return $query;
}

/**
 * Implements hook_panels_pane_content_alter().
 * Some code here taken from the ajax_pane project. Thank you to creaoy, twistor, and undertext.
 */
function breakpoint_panels_panels_pane_content_alter($content, $pane, $args, $context) {

  drupal_add_js(drupal_get_path('module', 'breakpoint_panels') . '/js/breakpoint_panels.js');
  if ($path = libraries_get_path('enquire.js')) {
    drupal_add_js($path . '/enquire.min.js');
  }
  if ($path = libraries_get_path('matchMedia.js')) {
    drupal_add_js($path . '/matchMedia.js');
  }

  if (
    !empty($pane->ajax_rendering)
    || empty($pane->configuration['breakpoints'])
    || empty($pane->pid)
    ) {
    // Don't rewrite content. This is the ajax call.
    return;
  }

  // Default ajax to TRUE, then prove otherwise.
  $use_ajax = TRUE;

  // Determine if the pane is loaded for all breakpoints. If so do not use ajax to load.
  $breakpoints_list = breakpoint_panels_fetch_breakpoints_list();

  $all_found = TRUE;
  $none_found = TRUE;
  if (!empty($breakpoints_list)) {
    foreach ($breakpoints_list as $breakpoint) {
      if (!empty($pane->configuration['breakpoints'][$breakpoint])) {
        $none_found = FALSE;
      }
      else {
        $all_found = FALSE;
      }
    }
  }

  if ($none_found || $all_found) {
    $use_ajax = FALSE;
  }

  // If ajax is not needed for this pane, bail.
  if (!$use_ajax) {
    return;
  }

  $display = panels_get_current_page_display();

  // The cache-key variable is set by the panel-context render function.
  list($context, $task_name, $handler_name) = explode(':', $display->cache_key);

  // Build the url src for the ajax call, code originally from ajax_pane.module.
  $url = "breakpoint-panels/get-pane/{$pane->did}/{$pane->pid}";
  if (array_key_exists('context', $pane->configuration)) {
    // Add the page-manager task name.
    $url .= '/' . $task_name;
    // Add the name of the context which is supplied to this pane.
    $url .= '/' . $pane->configuration['context'];
  }
  else {
    // Add dummy strings so I keep the same order in the parser.
    // Add the page-manager task name.
    $url .= '/n';
    // Add the name of the context which is supplied to this pane.
    $url .= '/n';
  }

  $query_key = base64_encode(serialize($_GET));
  if (!empty($query_key)) {
    $url .= '/' . $query_key;
  }

  $url = url($url, array('query' => array('destination' => url($_GET['q']), 'redirect' => url($_GET['q']))));
  $id = uniqid('breakpoint-panels-pane-' . $pane->pid . '-');

  unset($content->title);
  $classes = '';
  foreach ($pane->configuration['breakpoints'] as $bp => $val) {
    if ($val==0) {
      $classes .= ' ' . $bp;
    }
  }
  $classes = trim($classes);

  $bps = breakpoint_panels_get_breakpoints();
  $ipemessage = '';
  $hides = array();

  // Add CSS to page.
  $css = '';
  foreach ($bps as $name => $bp) {
    //$clean = breakpoint_panels_css_name($bp->name);
    if (strpos($classes, $bp->breakpoint_panels_name) >- 1) {
      array_push($hides, $bp->breakpoint_panels_name);
      $ipemessage .= '<br />Hidden from ' . $bp->name;
    }
    $css .= "@media " . $bp->breakpoint . " { " . '.' . $bp->breakpoint_panels_name . " { display:none } }\n .panels-ipe-editing " . '.hide_' . $bp->breakpoint_panels_name . " { display:block }\n";
  }
  drupal_add_css($css, array('group' => CSS_DEFAULT, 'type' => 'inline'));
  drupal_add_css(drupal_get_path('module', 'breakpoint_panels') . '/breakpoint_panels.css', array('type' => 'file', 'media' => 'screen'));

  $ipemessage .= (!empty($ipemessage)) ? '<br /><br />' : '';

  $content->content = '<div class="' . $classes . '" pane="' . $pane->pid . '" display="' . $display->did . '"><div class="ipemessage">' . $ipemessage . '</div><div id="' . $id . '" class="bp-ajax-pane" src="' . $url . '"></div></div>';

  $content->use_ajax_render = TRUE;
}

/**
 * Fetch a list of the active breakpoints in use with css safe names.
 */
function breakpoint_panels_fetch_breakpoints_list() {
  // Use the current theme
  global $theme_key;

  // Call the breakpoints.module function for active breakpoints.
  $breakpoints = breakpoint_panels_get_breakpoints($theme_key);

  // Clean up result, add css safe name.
  $breakpoints_list = array();
  if (!empty($breakpoints)) {
    foreach ($breakpoints as $bp) {
      $breakpoints_list[] = $bp->breakpoint_panels_name;
    }
  }

  return $breakpoints_list;
}

/**
 * Looks up the menu handler for a URL, and provides the correct contexts.
 *
 * Each of the panel task plugins provides a default context based on the menu
 * path.
 */
function breakpoint_panels_panels_get_task_context($task_name) {
  $task = page_manager_get_task($task_name);

  // Invoke the module's hook_esi_get_context_arguments to get the context
  // provided by that task.
  $context_arguments = module_invoke($task['module'], 'breakpoint_panels_get_context_arguments', $task['name']);

  // Parse the arguments into context objects.
  ctools_include('context');
  ctools_include('context-task-handler');
  $contexts = ctools_context_handler_get_task_contexts($task, '', $context_arguments);

  return array($context_arguments, $contexts);
}

/**
 * Implements hook_breakpoint_panels_get_context_arguments().
 *
 * On behalf implementation of Ajax panes api for page_manager.module.
 */
function page_manager_breakpoint_panels_get_context_arguments($task_name) {
  switch ($task_name) {
    // The blog, poll, and contact_site tasks don't provide default context.
    case 'blog':
    case 'poll':
    case 'contact_site':
      return array();

    // The blog_user, and contact_user tasks provide a user-object.
    case 'blog_user':
    case 'contact_user':
      $uid = arg(1);
      $account = user_load($uid);
      return array($account);

    // The comment_reply task provide a node object and a comment CID.
    case 'comment_reply':
      // Path is comment/reply/%node
      $nid = arg(2);
      $pid = arg(3);
      $node = node_load($nid);
      return array($node, $pid);

    // The node_edit and node_view tasks provide a node object.
    case 'node_edit':
    case 'node_view':
      $nid = arg(1);
      $node = node_load($nid);
      return array($nid);

    case 'search':
      // @todo return array($keys);
    case 'term_view':
      // @todo return array($terms, $depth);
  }
}

/**
 * Returns a safe name for the css class.
 */
// function breakpoint_panels_css_name($name) {
//   $name = strtolower($name);
//   if (strpos($name, 'pane_') === 0) {
//     $name = str_replace('pane_', '', $name);
//   }
//   $name = 'hide_' . $name;
//   $name = drupal_clean_css_identifier($name);

//   return $name;
// }

/**
 * Returns list of all breakpoints with CSS friendly name.
 */
function breakpoint_panels_get_breakpoints() {
  $breakpoints = breakpoints_breakpoint_load_all_active();
  foreach ($breakpoints as $ix => $bp) {
    $arr_test = explode('.', $bp->machine_name);
    if (is_array($arr_test)) {
      $base = array_pop($arr_test);
    }
    else {
      $base = $tmp->machine_name;
    }
    $breakpoints[$ix]->breakpoint_panels_name = drupal_clean_css_identifier($base . '-' . $bp->id);

  }

  return $breakpoints;
}
